/* ************************************************************************** */
/*                                                                            */
/*                                                        ::::::::            */
/*   ft_piece.c                                         :+:    :+:            */
/*                                                     +:+                    */
/*   By: ayundina <marvin@codam.nl>                   +#+                     */
/*                                                   +#+                      */
/*   Created: 2019/06/25 11:01:21 by ayundina      #+#    #+#                 */
/*   Updated: 2019/06/25 11:01:24 by ayundina      ########   odam.nl         */
/*                                                                            */
/* ************************************************************************** */

#include "filler.h"

/*
**	To find a point on a map if a map saved as a string. Below is
**	a visualised map string with its index starting as 00 in coordinates
**	row = 0 and column = 0.
**
**	Map size is:
**	map_rows = 16
**	map_cols = 16
**
**	r	c	00	01	02	03	04	05	06	07	08	09	10	11	12	13	14	15	\n
**
**	00		00	01	02	03	04	05	06	07	08	09	10	11	12	13	14	15	16
**	01		17	18	19	20	21	22	23	24	25	26	27	28	39	30	31	32	33
**	02		34	35	36	37	38	39	40	41	42	43	44	45	46	47	48	49	50
**	03		51	52	53	54	55	56	57	58	59	60	61	62	63	64	65	66	67
**	04		68	69	70	71	72	73	74	75	76	77	78	79	80	81	82	83	84
**	05		85	86	87	88	89	90	91	92	93	94	95	96	97	98	99	100	101
**	06		102	103	104	105	106	107	108	109	110	111	112	113	114	115	116	117	118
**	07		119	120	121	122	123	124	125	126	127	128	129	130	131	132	133	134	135
**	08		136	137	138	139	140	141	142	143	144	145	146	147	148 149 150	151	152
**	09		153	154	155	156	157	158	159	160	161	162	163	164	165	166	167	168	169
**	10		170	171	172	173	174	175	176	177	178	179	180	181	182	183	184	185	186
**	11		187	188	189	190	191	192	193	194	195	196	197	198	199	200	201	202	203
**	12		204	205	206	207	208	209	210	211	212	213	214	215	216	217	218	219	220
**	13		221	222	223	224	225	226	227	228	229	230	231	232	233	234	235	236	237
**	14		238	239	240	241	242	243	244	245	246	247	248	249	250	251	252	253	254
**	15		255	256	257	258	259	260	261	262	263	264	265	266	267	268	269	270	271
**
**	int	r = 0;
**	int c = 0;
**
**	while (r < map_rows)
**	{
**		while (c < map_cols)
**		{
**			reaching_each_point_of_the_map = r * map_cols + c + r;
**			c++;
**		}
**		c = 0;
**		r++;
**	}
**
**	for example map index 106 = r * map_cols + c + r
**								6 * 16		 + 4 + 6 = 106
*/

/*
**	ft_exact_width() function counts a number of blocks in a piece horizontally
**
**	Param 1: char *piece is a piece generated by filler_vm
**
**	Param 2: int row is a nuber of rows in a piece
**
**	Param 3: int col is a nuber of columns in a piece
**
**	Returns: a width of a piece
*/

static int	ft_exact_width(char *piece, int row, int col)
{
	int	r;
	int	c;
	int	width;

	r = 0;
	c = 0;
	width = 0;
	while (r < row)
	{
		while (piece[r * col + c + r] != '\n')
		{
			if (piece[r * col + c + r] == '*')
			{
				if (width < c + 1)
					width = c + 1;
			}
			c++;
		}
		col = c;
		c = 0;
		r++;
	}
	return (width);
}

/*
**	ft_left_offset() function counts the left offset of a piece
**
**	Param 1: char *piece is a piece generated by filler_vm
**
**	Param 2: int row is a nuber of rows in a piece
**
**	Param 3: int col is a nuber of columns in a piece
**
**	Returns: left offset of a piece
*/

static int	ft_left_offset(char *piece, int row, int col)
{
	int	r;
	int	c;
	int	offset;

	r = 0;
	c = 0;
	offset = 0;
	while (r < row)
	{
		while (c < col)
		{
			if (piece[r * col + c + r] == '*')
			{
				if (offset == 0 || offset > c)
					offset = c;
			}
			if (piece[r * col + c + r] == '*' && c == 0)
				return (0);
			c++;
		}
		c = 0;
		r++;
	}
	return (offset);
}

/*
**	ft_trim_piece() function removes empty columns
**	of a piece on the left and the right sides
**
**	Param 1: char *piece is a piece generated by filler_vm
**
**	Param 2: int row is a nuber of rows in a piece
**
**	Param 3: int col is a nuber of columns in a piece
**
**	Param 4: int *col_offset to save the left offset of a piece
**
**	Returns: none
*/

static void	ft_trim_piece(char *piece, int row, int col, int *col_offset)
{
	size_t	i;

	i = 0;
	*col_offset = ft_left_offset(piece, row, col);
	if (*col_offset)
	{
		while (i < ft_strlen(piece))
		{
			ft_memmove(piece + i, piece + i + *col_offset,
					ft_strlen(piece + i + *col_offset));
			i += col - *col_offset + 1;
			piece[ft_strlen(piece) - *col_offset] = '\0';
		}
	}
}

/*
**	ft_get_piece() function reads a piece given by filler_vm from stdin,
**	counts number of rows and row offset in the given piece,
**	counts number of columns and left offset in the given piece,
**	trims empty rows and columns
**
**	Param 1: t_game *gm is a struct members of which hold
**	all data necessary for the game
**
**	Returns: 0 if success, -1 if an error ocured
*/

int			ft_get_piece(t_piece *piece)
{
	int		tmp_row;
	char	*line;

	tmp_row = 0;
	piece->row_offset = 0;
	piece->col_offset = 0;
	while (piece->rows && get_next_line(0, &line))
	{
		if (!line)
			return (-1);
		if (!ft_strchr(line, '*') && *piece->piece == '\0')
			piece->row_offset++;
		if (ft_strchr(line, '*'))
		{
			ft_strcpy(piece->piece + ft_strlen(piece->piece), line);
			*(piece->piece + ft_strlen(piece->piece)) = '\n';
			tmp_row++;
		}
		ft_strdel(&line);
		piece->rows--;
	}
	piece->rows = tmp_row;
	ft_trim_piece(piece->piece, piece->rows, piece->cols, &piece->col_offset);
	piece->cols = ft_exact_width(piece->piece, piece->rows, piece->cols);
	return (0);
}
